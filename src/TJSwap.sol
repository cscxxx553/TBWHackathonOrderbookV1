// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.19;

import "./AMM.sol";
// import {ERC20} from "openzeppelin/token/ERC20/ERC20.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";
import "chainlink/src/v0.8/automation/AutomationCompatible.sol";

contract TJSwap is Ownable, AutomationCompatibleInterface {
    AMM _theAmm = AMM(0x1d9Bf45036e0078F1058dca9935f1f3cB6D141B6);
    // uint16 internal constant DEFAULT_BIN_STEP = 10;
    uint256 public token0Price;
    uint256 public token1Price;
    uint256 public tokenRatio;
    /**
     * Public counter variable
     */
    uint256 public counter;

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    constructor(uint256 updateInterval, uint256 _token0Price, uint256 _token1Price){
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        token0Price = _token0Price;
        token1Price = _token1Price;
        tokenRatio = (token0Price*100) / token1Price;
    }

       function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            _swapExactTForTV1();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function _swapExactTForTV1() internal {
        IERC20 token0 = IERC20(0xafb5188894da64AcFF12Ec6cb93bCBB45F555910);
        IERC20 token1 = IERC20(0x76097e10C5095aF7279c2eA53A3Cf6801D10e807);
        // require((IERC20(token0).balanceOf(address(this))) < 1000000000000000000, "Insufficient balance of token1.");
        // require((IERC20(token1).balanceOf(address(this))) < 400000000000000000000, "Insufficient balance of token2.");
        // require(sellAmountPerTime > 10000000000000000, "The Sell Amount Per Time should be greater than 0.01 .");
        // require(sellAmountPerTime < 1000000000000000000000, "The Sell Amount Per Time should be less than 1000 .");
        // require(priceCeiling > 0, "The Price Ceiling should be greater than 0 .");
        // require(priceCeiling > priceFloor, "The Price Ceiling should be greater than Price Floor .");
        // require((priceCeiling - priceFloor) > 10, "The Price Ceiling should be greater than Price Floor .");
        // require(currentPriceOfSwapPair > 0, "The current price of swap pair can not be 0 .");
        // require(pointPrice > 0, "The point price can not be 0 .");
        
        uint256 newPriceRatio = (token0Price*100)/token1Price;
        if(newPriceRatio > tokenRatio && ((((newPriceRatio-tokenRatio)*100)/tokenRatio)>3)){
            token0.approve(address(_theAmm), 100000000000000000000);
            _theAmm.swap(address(token0), 1000000000000000000);
            tokenRatio = (token0Price*100)/token1Price;
        }else if(tokenRatio > newPriceRatio && ((((tokenRatio-newPriceRatio)*100)/newPriceRatio)>3)){
            token1.approve(address(_theAmm), 40000000000000000000000);
            _theAmm.swap(address(token1), 400000000000000000000);
            tokenRatio = (token0Price*100)/token1Price;
        }

    }

    function setToken0Price(uint256 newToken0Price) external {
        token0Price = newToken0Price;
    }

    function setToken1Price(uint256 newToken1Price) external {
        token1Price = newToken1Price;
    }

    function getNewPriceRatio() external view returns(uint256){
        return (token0Price*100)/token1Price;
    }

    receive() external payable {}
}

